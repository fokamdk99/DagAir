\newpage
\section{Pomiary}
Treść sekcji zawiera opis czujników oraz innych elementów elektronicznych
wykorzystanych do zbudowania zestawu wykonującego pomiary temperatury
oraz natężenia światła. Podrozdział 8.1 przedstawia szczegóły implementacyjne
dotyczące utworzonego oprogramowania sterującego wykonywaniem pomiarów.

W ramach niniejszej pracy przygotowano zestaw pomiarowy, który 
w regularnych odstępach czasu bada aktualną wartość temperatury oraz
natężenia światła. Zestaw został złożony z następujących elementów:

\begin{itemize} % lista nienumerowana
    \item Moduł WEMOS D1 Uno R3 ESP8266 WIFI
    \item Fotorezystor LDR GL5528
    \item Czujnik temperatury i wilgotności DHT11
    \item Rezystory 1 kOhm
    \item przewody połączeniowe żeńsko-męskie
\end{itemize}

Moduł WEMOS jest mikrokontrolerem opartym o kontroler ATmega328P. Posiada
11 portów wejścia-wyjścia pozwalających na dołączenie zewnętrznych 
urządzeń. Płytka została fabrycznie wyposażona w moduł WIFI ESP8266. Za
jego pomocą mogą być wysyłane pomiary.

Fotorezystor służy do pomiaru natężenia światła. Został wykonany 
z półprzewodników, które w temperaturze działania nie mają elektronów 
w paśmie przewodnictwa. Padające na półprzewodnik fotony o energii 
większej od przerwy energetycznej przemieszczają elektrony z pasma 
walencyjnego do pasma przewodnictwa, w wyniku którego powstają pary 
dziura-elektron. Zjawisko nazywane jest efektem fotoelektrycznym 
wewnętrznym.

Czujnik temperatury DHT11 bada aktualne wartości tego
parametru. Mierzony zakres temperatury to -20\degree  - +60\degree C.
Jego rozdzielczość wynosi 0.1\degree C, a dokładność 2\degree C.

\subsection{Oprogramowanie mikrokontrolera}

Do rozwoju oprogramowania do mikrokontrolera WEMOS wykorzystano narzędzie 
Arduino IDE, będące rozbudowanym edytorem pozwalającym na kompilację,
przesyłanie plików wykonywalnych na płytkę przy pomocy kabla USB oraz
debugowanie i podgląd logów produkowanych przez mikrokontroler w czasie 
rzeczywistym. Do utworzenia kodu został wykorzystany język C.

Zadaniem mikrokontrolera było:

\begin{itemize} % lista nienumerowana
    \item Zebranie aktualnych pomiarów temperatury i natężenia światła
    \item przygotowanie wiadomości z uzyskanymi pomiarami
    \item wysłanie wiadomości przy pomocy protokołu MQTT przez moduł WIFI na 
    kolejkę brokera wiadomości RabbitMQ
\end{itemize}

Poniżej został przedstawiony przygotowany kod.

\begin{lstlisting}
    void setup() {
      Serial.begin(115200);
      dht.begin();
     
      WiFi.mode(WIFI_STA);
      WiFi.begin(WIFI_SSID, WIFI_PASS);
     
      while (WiFi.status() != WL_CONNECTED)
      {
        delay(100);
      }
      
      client.setServer(RABBITMQ_BROKER, RABBITMQ_PORT);
      client.setCallback(callback);
    }
     
    void loop() {
      if ( !client.connected() ) {
        reconnect();
      }
      
      float temperature = readTemperature(&dht);
      int illuminance = analogRead(ILLUMINANCEPIN);
      publish_measurements(temperature, illuminance, false);
      
      delay(60000);
    
      client.loop();
    }
\end{lstlisting}

Każdy z programów wgrywanych na płytkę powinien zawierać dwie główne funkcje:

\begin{itemize}
    \item \textit{void setup()} - wewnątrz metody definiowane są obiekty oraz zmienne 
    potrzebne przez cały czas działania mikrokontrolera
    \item \textit{void loop()} - metoda wywoływana jako druga w kolejności po \textit{setup()},
    jest powtarzana przez resztę cyklu działania mikrokontrolera 
\end{itemize}

Na początku definiowana jest szyna, za pomocą której przesyłane są dane do 
modułu WIFI. Moduł wspiera prędkość transmisji na poziomie 115200 bitów na 
sekundę (ang. \textit{baud rate}). Następnie tworzony jest klient, którego zadaniem
jest wysyłanie pomiarów na kolejkę brokera wiadomości. 

Wewnątrz metody \textit{loop()} co 60 sekund zbierane są pomiary, po czym zostają opublikowane
na kolejkę. Pomiary wykonywane są przy użyciu poniższego kodu.

\begin{lstlisting}
    #include "DHT.h"

    #define DHTPIN 4
    #define DHTTYPE DHT11
    
    int ILLUMINANCEPIN = A0;
    
    DHT dht(DHTPIN, DHTTYPE);
    
    float readTemperature(DHT *dht){
      float t = dht->readTemperature();
     
      if (isnan(t))
      {
        Serial.println(
            "Error while reading current 
            temperature value");
      }
      
      return t;
    }
\end{lstlisting}

Główną rolę pełni obiekt dht, za pomocą którego można komunikować się
z czujnikiem. Typ czujnika został zdefiniowany przy użyciu makra \textit{DHTTYPE}.
Numer pinu, do którego został wpięty kabel łączący płytkę z czujnikiem,
został oznaczony pzy użyciu makra \textit{DHTPIN}. Pomiar temperatury odbywa się
przez wywołanie funkcji \textit{readTemperature()}. 

Pomiar z fotorezystora można odczytać przy użyciu komendy:  

\begin{lstlisting}
    analogRead(ILLUMINANCEPIN)
\end{lstlisting}

gdzie \textit{ILLUMINANCEPIN} oznacza numer pinu, do 
którego wpięty jest kabel łączący płytkę z fotorezystorem.

Warto wyjaśnić wartości zmiennych związanych z brokerem wiadomości:
\begin{lstlisting}
    const char* RABBITMQ_BROKER = "192.168.0.12";
    int        RABBITMQ_PORT     = 1883;
    const char* RABBITMQ_TOPIC  = "room_measurements";
    const char* RABBITMQ_SUBSCRIPTION  
    = "request_measurement";
    const char* RABBITMQ_USER = "guest";
    const char* RABBITMQ_PASSWORD = "guest";
    const char* RABBITMQ_SENSOR_ID = "968376";
\end{lstlisting}

\begin{itemize}
    \item RABBITMQ\_BROKER: adres IP serwera, na którym uruchomiony jest broker wiadomości
    \item RABBITMQ\_PORT: numer portu serwera, na którym nasłuchuje broker
    \item RABBITMQ\_TOPIC: temat, na który wysyłane są wiadomości z mikrokontrolera
    na kolejkę
    \item RABBITMQ\_SUBSCRIPTION: temat, na który nasłuchuje mikrokontroler
    \item RABBITMQ\_USER: nazwa użytkownika, za pomocą którego płytka jest uwierzytelniana
    \item RABBITMQ\_PASSWORD: hasło dla wykorzystywanego użytkownika
\end{itemize}

Wiadomość do brokera jest wysyłana w metodzie \textit{send\_measurements()}:

\begin{lstlisting}
    void send_measurements(
        float temperature, int illuminance){
      char temperatureChar[64];
      int ret = snprintf(
          temperatureChar, sizeof temperatureChar, 
          "%f", temperature);
      if (ret < 0) {
          return;
      }
      if (ret >= sizeof temperatureChar) {
           return;
      }
      char illuminanceChar[64];
      ret = snprintf(
          illuminanceChar, sizeof illuminanceChar, 
          "%d", illuminance);
      if (ret < 0) {
          return;
      }
      if (ret >= sizeof illuminanceChar) {
           return;
      }
    
      char* measurement = (char*)malloc(256+1+3); 
      //4*64 + 3 semicolons + EOF
      strcpy(measurement, temperatureChar);
      strcat(measurement, ";");
      strcat(measurement, illuminanceChar);
      strcat(measurement, ";");
      strcat(measurement, RABBITMQ_SENSOR_ID);
    
      time_t t = time(NULL);
      struct tm tm = *localtime(&t);
    
      client.publish(RABBITMQ_TOPIC, measurement);
    
      free(measurement);
    }
\end{lstlisting}

Mikrokontroler nasłuchuje na wiadomości o temacie \textit{\\RABBITMQ\_SUBSCRIPTION}:

\begin{lstlisting}
    void callback(
        char* topic, byte* payload, unsigned int length) {
      char* sensorId = (char*)payload;
    
      String messageTemp;
      
      for (int i = 0; i < length; i++) {
        Serial.print((char)payload[i]);
        messageTemp += (char)payload[i];
      }
    
      if(strcmp(topic, RABBITMQ_SUBSCRIPTION) 
      == 0 && strcmp(sensorId, RABBITMQ_SENSOR_ID)){
        float temperature = readTemperature(&dht);
        int illuminance = analogRead(ILLUMINANCEPIN);
        publish_measurements(
            temperature, humidity, illuminance, true);
      }
    }
\end{lstlisting}

Serwis SSDS może zażądać wysłania aktualnych pomiarów poprzez wysłanie do brokera 
wiadomości o temacie \textit{RABBITMQ\_SUBSCRIPTION}.